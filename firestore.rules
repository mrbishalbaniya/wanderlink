
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isSignedIn() {
      return request.auth != null;
    }

    function isListOfUids(list) {
      return list is list && (list.size() == 0 || list[0] is string);
    }

    // User Profile Validation
    function isValidUserProfileData(data) { // For create
      return data.keys().hasAll(['uid', 'email', 'name', 'avatar', 'joinedAt']) &&
             data.uid is string && data.uid == request.auth.uid &&
             data.email is string &&
             data.name is string && data.name.size() > 0 &&
             data.avatar is string && data.avatar.size() > 0 &&
             data.joinedAt == request.time &&
             (data.username == null || (data.username is string && data.username.size() >= 3 && data.username.matches("^[a-z0-9_]+$"))) &&
             (data.dateOfBirth == null || data.dateOfBirth is timestamp) &&
             (data.gender == null || data.gender is string) &&
             (data.interestedIn == null || (data.interestedIn is list && (data.interestedIn.size() == 0 || data.interestedIn[0] is string))) &&
             (data.bio == null || (data.bio is string && data.bio.size() <= 1000)) &&
             (data.phoneNumber == null || data.phoneNumber is string) &&
             (data.profileCompletionScore == null || data.profileCompletionScore is number) &&
             (data.idVerificationImageUrl == null || data.idVerificationImageUrl is string) &&
             (data.isIdVerified == null || data.isIdVerified is bool);
             // Add more optional field checks as needed
    }

    function isValidUserProfileUpdate(requestData, existingData) { // For update
      let R = requestData;
      let E = existingData;
      return R.uid == E.uid &&
             R.email == E.email && // Assuming email cannot be changed by user directly
             R.joinedAt == E.joinedAt &&
             (R.name is string && R.name.size() > 0) &&
             (R.avatar is string && R.avatar.size() > 0) &&
             (R.username == null || (R.username is string && R.username.size() >= 3 && R.username.matches("^[a-z0-9_]+$"))) &&
             (R.dateOfBirth == null || R.dateOfBirth is timestamp) &&
             (R.gender == null || R.gender is string) &&
             (R.interestedIn == null || (R.interestedIn is list && (R.interestedIn.size() == 0 || R.interestedIn[0] is string))) &&
             (R.bio == null || (R.bio is string && R.bio.size() <= 1000)) &&
             (R.phoneNumber == null || R.phoneNumber is string) &&
             (R.socialMediaLinks == null || R.socialMediaLinks is map) &&
             (R.travelStyles == null || (R.travelStyles is list && (R.travelStyles.size() == 0 || R.travelStyles[0] is string))) &&
             (R.favoriteDestinations == null || (R.favoriteDestinations is list && (R.favoriteDestinations.size() == 0 || R.favoriteDestinations[0] is string))) &&
             (R.bucketList == null || (R.bucketList is list && (R.bucketList.size() == 0 || R.bucketList[0] is string))) &&
             (R.preferredTransportModes == null || (R.preferredTransportModes is list && (R.preferredTransportModes.size() == 0 || R.preferredTransportModes[0] is string))) &&
             (R.interests == null || (R.interests is list && (R.interests.size() == 0 || R.interests[0] is string))) &&
             (R.languagesSpoken == null || (R.languagesSpoken is list && (R.languagesSpoken.size() == 0 || R.languagesSpoken[0] is string))) &&
             (R.currentLocation == null || R.currentLocation is map) &&
             (R.matchPreferences == null || R.matchPreferences is map) &&
             (R.idVerificationImageUrl == null || R.idVerificationImageUrl is string) &&
             (R.isIdVerified == null || R.isIdVerified is bool) && // isIdVerified should ideally only be updatable by an admin/backend process
             (R.profileCompletionScore == null || R.profileCompletionScore is number) &&
             (R.lastUpdated == request.time);
    }

    // Post Validation
    function isValidPostData(data) { // For create
      return data.keys().hasAll(['userId', 'title', 'caption', 'coordinates', 'category', 'images', 'createdAt', 'likes', 'savedBy', 'commentCount']) &&
             data.userId is string && data.userId == request.auth.uid &&
             data.title is string && data.title.size() >= 5 && data.title.size() <= 100 &&
             data.caption is string && data.caption.size() >= 10 && data.caption.size() <= 1000 &&
             (data.locationLabel == null || (data.locationLabel is string && data.locationLabel.size() <= 100)) &&
             data.coordinates is map && data.coordinates.latitude is number && data.coordinates.longitude is number &&
             data.category is string && ['hiking', 'city', 'beach', 'food', 'culture', 'nature', 'other'].hasAny([data.category]) &&
             data.images is list && (data.images.size() == 0 || data.images[0] is string) && data.images.size() <= 5 &&
             data.createdAt == request.time &&
             data.likes is list && data.likes.size() == 0 &&
             (data.savedBy == null || (data.savedBy is list && data.savedBy.size() == 0)) &&
             data.commentCount is number && data.commentCount == 0;
    }

    function isUpdatingAllowedPostContentFields(requestData, existingData) { // For post content update by owner
      let modifiableFields = ['title', 'caption', 'locationLabel', 'category', 'images', 'lastUpdated'];
      let incomingKeys = requestData.keys();
      // Owner content update should not touch these fields directly, they are managed by other rules/logic
      let unchangedByOwnerFields = requestData.userId == existingData.userId &&
                                   requestData.createdAt == existingData.createdAt &&
                                   requestData.likes == existingData.likes &&
                                   requestData.savedBy == existingData.savedBy &&
                                   requestData.commentCount == existingData.commentCount;

      return incomingKeys.hasOnly(modifiableFields.concat(['userId', 'createdAt', 'likes', 'savedBy', 'commentCount', 'coordinates'])) &&
             unchangedByOwnerFields &&
             (requestData.title is string && requestData.title.size() >= 5 && requestData.title.size() <= 100) &&
             (requestData.caption is string && requestData.caption.size() >= 10 && requestData.caption.size() <= 1000) &&
             (requestData.lastUpdated == request.time);
             // Add more validation for other modifiable fields if necessary
    }

    function isUpdatingLikesOrSavesOnly(requestData, existingData, authUid) {
      let R = requestData; // request data
      let E = existingData; // existing data
      let affected = R.diff(E).affectedKeys();

      // Check if only 'likes' or 'savedBy' or both are in affectedKeys
      let onlyLikesOrSavesChanged = (affected.has('likes') && affected.size() == 1) ||
                                    (affected.has('savedBy') && affected.size() == 1) ||
                                    (affected.hasAll(['likes', 'savedBy']) && affected.size() == 2);

      // Ensure other critical fields remain unchanged
      let coreFieldsUnchanged = R.userId == E.userId &&
                                R.title == E.title &&
                                R.caption == E.caption &&
                                R.locationLabel == E.locationLabel &&
                                R.coordinates.latitude == E.coordinates.latitude &&
                                R.coordinates.longitude == E.coordinates.longitude &&
                                R.category == E.category &&
                                R.images == E.images &&
                                R.createdAt == E.createdAt &&
                                R.commentCount == E.commentCount;

      let likesValid = true;
      if (affected.has('likes')) {
        let likesBefore = E.likes;
        let likesAfter = R.likes;
        let addedLike = likesAfter.size() == likesBefore.size() + 1 && authUid in likesAfter && !(authUid in likesBefore);
        let removedLike = likesAfter.size() == likesBefore.size() - 1 && !(authUid in likesAfter) && authUid in likesBefore;
        likesValid = (addedLike || removedLike) && isListOfUids(likesAfter);
      }

      let savedByValid = true;
      if (affected.has('savedBy')) {
        let savedByListBefore = E.savedBy == null ? [] : E.savedBy;
        let savedByListAfter = R.savedBy;
        let addedSave = savedByListAfter.size() == savedByListBefore.size() + 1 && authUid in savedByListAfter && !(authUid in savedByListBefore);
        let removedSave = savedByListAfter.size() == savedByListBefore.size() - 1 && !(authUid in savedByListAfter) && authUid in savedByListBefore;
        savedByValid = (addedSave || removedSave) && isListOfUids(savedByListAfter);
      }

      return onlyLikesOrSavesChanged && coreFieldsUnchanged && likesValid && savedByValid;
    }

    // Swipe Validation
    function isValidSwipeData(data) {
      return data.keys().hasAll(['swiperId', 'swipedUserId', 'action', 'timestamp']) &&
             data.swiperId is string && data.swiperId == request.auth.uid &&
             data.swipedUserId is string && data.swipedUserId != request.auth.uid &&
             data.action is string && (data.action == 'like' || data.action == 'skip') &&
             data.timestamp == request.time;
    }

    // Match Document ID helper
    function getMatchDocId(uid1, uid2) {
      return uid1 < uid2 ? uid1 + '_' + uid2 : uid2 + '_' + uid1;
    }


    // Collection Rules
    match /users/{userId} {
      // Public GET for basic profile info needed for display purposes elsewhere
      allow get: if isSignedIn(); // Allow any signed-in user to GET a profile (e.g., for PostCard, MatchCard)
                                  // Consider if more granular field control is needed for `get` vs full `read`

      // Owner can READ all their own data (includes list operations if they were relevant, and get)
      allow read: if isSignedIn() && isOwner(userId);

      allow create: if isOwner(userId) && isValidUserProfileData(request.resource.data);
      allow update: if isSignedIn() && isOwner(userId) && isValidUserProfileUpdate(request.resource.data, resource.data);
      allow delete: if false; // Users generally shouldn't delete their own accounts directly
    }

    match /posts/{postId} {
      allow read: if isSignedIn();

      allow create: if isSignedIn() &&
                      request.resource.data.userId == request.auth.uid &&
                      isValidPostData(request.resource.data);

      // Owner can update their post content
      allow update: if isSignedIn() &&
                      request.auth.uid == resource.data.userId &&
                      isUpdatingAllowedPostContentFields(request.resource.data, resource.data);

      // Any signed-in user can like/save (this rule is ORed with the one above for updates)
      allow update: if isSignedIn() &&
                      isUpdatingLikesOrSavesOnly(request.resource.data, resource.data, request.auth.uid);

      allow delete: if isSignedIn() && isOwner(resource.data.userId);
    }

    match /matches/{matchId} {
      allow read: if isSignedIn() && request.auth.uid in resource.data.users;
      allow create: if isSignedIn() &&
                       (request.resource.data.users[0] == request.auth.uid || request.resource.data.users[1] == request.auth.uid) &&
                       request.resource.data.users.size() == 2 &&
                       request.resource.data.users[0] < request.resource.data.users[1] && // Ensures consistent ID and prevents self-match in array
                       request.resource.data.users[0] != request.resource.data.users[1] &&
                       !exists(/databases/$(database)/documents/matches/$(getMatchDocId(request.resource.data.users[0], request.resource.data.users[1]))) &&
                       request.resource.data.timestamp == request.time;
      allow update, delete: if false; // Matches are immutable
    }

    match /swipes/{swipeId} {
      allow read: if false; // Swipes are not meant to be read directly by clients
      allow create: if isSignedIn() && isValidSwipeData(request.resource.data);
      allow update, delete: if false; // Swipes are immutable
    }

    // Example for a potential 'chats' collection if you add direct messaging
    // match /chats/{chatId} {
    //   allow read, write: if isSignedIn() && request.auth.uid in resource.data.participants;
    //   match /messages/{messageId} {
    //     allow read: if isSignedIn() && request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants;
    //     allow create: if isSignedIn() && request.auth.uid == request.resource.data.senderId &&
    //                     request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants;
    //   }
    // }
  }
}

    